<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Voice Text Assistant</title>
    <script src="https://cdn.tailwindcss.com"></script>
</head>

<body class="bg-gray-50 text-gray-800">

    <div class="max-w-6xl mx-auto p-6">
        <div class="grid grid-cols-1 md:grid-cols-4 gap-6">
            <aside class="md:col-span-1 bg-white rounded-lg shadow p-4" id="leftPanel">
                <div class="flex items-center justify-between mb-4">
                    <h2 class="text-lg font-semibold">History</h2>
                    <button id="logoutBtn" class="text-sm text-red-600 hover:underline">Logout</button>
                </div>
                <div id="historyList" class="space-y-3 text-sm text-gray-700">(loading...)</div>
            </aside>

            <main class="md:col-span-3">
                <div class="bg-white rounded-lg shadow p-6">
                    <div class="flex items-start justify-between">
                        <div>
                            <h1 class="text-2xl font-bold">üé§ Voice Text Assistant</h1>
                            <p class="text-sm text-gray-500">Real-time transcription ‚Ä¢ Smart cleaning ‚Ä¢ Tone-based
                                output</p>
                        </div>
                        <div class="text-sm text-gray-500" id="latency">Latency: ‚Äî</div>
                    </div>

                    <div class="mt-4 flex flex-col md:flex-row md:items-center md:justify-between gap-3">
                        <div class="flex items-center gap-3">
                            <button id="speakBtn"
                                class="bg-indigo-600 text-white px-4 py-2 rounded shadow hover:bg-indigo-700">üéôÔ∏è
                                Speak</button>
                            <span id="status" class="text-sm text-gray-600">Idle</span>
                        </div>

                        <div class="flex items-center gap-2">
                            <label class="text-sm"><input type="checkbox" id="dictationToggle" checked
                                    class="mr-1">Dictation</label>
                            <label class="text-sm"><input type="checkbox" id="autocorrectToggle"
                                    class="mr-1">Auto-correct</label>
                            <label class="text-sm">Tone:
                                <select id="toneSelect" class="ml-2 border rounded px-2 py-1">
                                    <option value="neutral">Neutral</option>
                                    <option value="professional">Professional</option>
                                    <option value="friendly">Friendly</option>
                                    <option value="chat">Chat</option>
                                </select>
                            </label>
                        </div>
                    </div>

                    <div class="mt-4 flex items-center gap-2">
                        <button id="copyBtn" class="util-btn hidden bg-gray-100 px-3 py-1 rounded"
                            style="display:none">üìã Copy Cleaned</button>
                        <button id="downloadBtn" class="util-btn hidden bg-gray-100 px-3 py-1 rounded"
                            style="display:none">‚¨áÔ∏è Download</button>
                        <button id="saveBtn" class="util-btn hidden bg-green-600 text-white px-3 py-1 rounded"
                            style="display:none">üíæ Save</button>
                    </div>

                    <div class="mt-6 grid grid-cols-1 lg:grid-cols-3 gap-4">
                        <div class="lg:col-span-1">
                            <h3 class="text-sm font-medium text-gray-600">Original Transcript</h3>
                            <div id="originalTranscript"
                                class="mt-2 p-3 min-h-[120px] bg-gray-50 rounded border text-sm"></div>
                        </div>

                        <div class="lg:col-span-1">
                            <h3 class="text-sm font-medium text-gray-600">Result (Processed)</h3>
                            <div id="transcript" class="mt-2 p-3 min-h-[120px] bg-gray-50 rounded border text-sm"></div>
                            <div id="repeats" class="text-xs text-red-600 mt-2"></div>
                        </div>

                        <div class="lg:col-span-1">
                            <h3 class="text-sm font-medium text-gray-600">Cleaned Transcript</h3>
                            <div id="cleanedTranscript"
                                class="mt-2 p-3 min-h-[120px] bg-gray-50 rounded border text-sm"></div>

                            <h3 class="text-sm font-medium text-gray-600 mt-4">Suggestions</h3>
                            <div id="suggestions" class="mt-2 p-3 bg-gray-50 rounded border text-sm"></div>
                        </div>
                    </div>
                </div>
            </main>
        </div>
    </div>
    <script>
        // =====================
        // ELEMENT REFERENCES
        // =====================
        const speakBtn = document.getElementById("speakBtn");
        const statusEl = document.getElementById("status");
        const originalTranscriptEl = document.getElementById("originalTranscript");
        const transcriptEl = document.getElementById("transcript");
        const cleanedTranscriptEl = document.getElementById("cleanedTranscript");
        const suggestionsEl = document.getElementById("suggestions");
        const repeatsEl = document.getElementById("repeats");

        const copyBtn = document.getElementById("copyBtn");
        const downloadBtn = document.getElementById("downloadBtn");
        const saveBtn = document.getElementById("saveBtn");
        const latencyEl = document.getElementById("latency");

        const dictationToggle = document.getElementById("dictationToggle");
        const autocorrectToggle = document.getElementById("autocorrectToggle");
        const toneSelect = document.getElementById("toneSelect");

        // =============================
        // RULE-BASED TEXT CLEANING (NO ML)
        // =============================
        const fillerWords = [
            "um",
            "umm",
            "uh",
            "uhh",
            "ah",
            "er",
            "you know",
            "like",
            "matlab",
            "actually",
            "basically",
            "literally",
            "hmm",
            "mm",
        ];

        function escapeRegExp(s) {
            return s.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
        }

        function removeFillers(text) {
            for (let f of fillerWords) {
                const re = new RegExp(`\\b${escapeRegExp(f)}\\b`, "gi");
                text = text.replace(re, "");
            }
            return text.replace(/\s+/g, " ").trim();
        }

        function removeRepeatedPhrases(text, maxGram = 4) {
            let words = text.split(/\s+/);
            for (let L = maxGram; L >= 2; L--) {
                for (let i = 0; i + 2 * L <= words.length; i++) {
                    let match = true;
                    for (let k = 0; k < L; k++) {
                        if (words[i + k].toLowerCase() !== words[i + L + k].toLowerCase()) {
                            match = false;
                            break;
                        }
                    }
                    if (match) words.splice(i + L, L);
                }
            }
            return words.join(" ");
        }

        function autoPunctuate(text) {
            let parts = text.split(/\s+(?=(?:and|but|so|because)\b)/i);
            let out = "";
            for (let p of parts) {
                p = p.trim();
                if (!p) continue;
                p = p.charAt(0).toUpperCase() + p.slice(1);
                if (!/[.!?]$/.test(p)) p += ".";
                out += p + " ";
            }
            return out.trim();
        }

        function fixCapitalization(text) {
            return text.replace(/(^\w|[.!?]\s+\w)/g, (m) => m.toUpperCase());
        }

        function fixPronounI(text) {
            return text.replace(/\bi\b/g, "I");
        }

        function removeDoublePunctuation(text) {
            return text.replace(/([.!?])\1+/g, "$1");
        }

        function fixPunctuationSpacing(text) {
            return text.replace(/\s+([.!?])/g, "$1").replace(/([.!?])(\w)/g, "$1 $2");
        }

        function mergeShortSentences(text) {
            let sentences = text.split(/(?<=[.!?])\s+/);
            let out = [];
            for (let s of sentences) {
                let words = s
                    .trim()
                    .replace(/[.!?]$/, "")
                    .split(/\s+/)
                    .filter(Boolean);
                if (words.length > 0 && out.length > 0 && words.length <= 3) {
                    out[out.length - 1] =
                        out[out.length - 1].replace(/[.!?]$/, "") + ", " + s.trim();
                } else {
                    out.push(s.trim());
                }
            }
            return out.join(" ");
        }

        function autoParagraph(text) {
            let sentences = text.split(/(?<=[.!?])\s+/);
            let out = "";
            let count = 0;
            for (let s of sentences) {
                out += s.trim() + " ";
                count += s.length;
                if (count > 120) {
                    out += "\n\n";
                    count = 0;
                }
            }
            return out.trim();
        }

        function removeSmallRepeats(text) {
            return text.replace(/\b(\w{2,6})\b\s+\b\1\b/gi, "$1");
        }

        function cleanText(raw) {
            let t = (raw || "").toLowerCase();

            t = removeFillers(t);
            t = t.replace(/\b(\w+)\s+\1\b/gi, "$1");
            t = removeRepeatedPhrases(t);
            t = autoPunctuate(t);
            t = fixCapitalization(t);
            t = fixPronounI(t);
            t = removeSmallRepeats(t);
            t = removeDoublePunctuation(t);
            t = fixPunctuationSpacing(t);
            t = mergeShortSentences(t);
            t = autoParagraph(t);

            return t.trim();
        }

        // ===============================
        // TONE REWRITE
        // ===============================
        function applyTone(text, mode) {
            if (!text) return "";
            switch (mode) {
                case "professional":
                    return toProfessional(text);
                case "friendly":
                    return toFriendly(text);
                case "chat":
                    return toChat(text);
                default:
                    return text;
            }
        }

        function toProfessional(text) {
            let t = text;
            const map = [
                [/\bokay\b/gi, "Certainly"],
                [/\bok\b/gi, "Understood"],
                [/\bi think\b/gi, "I believe"],
                [/\bmaybe\b/gi, "perhaps"],
                [/\bcan't\b/gi, "cannot"],
                [/\bwon't\b/gi, "will not"],
                [/\bthanks\b/gi, "Thank you"],
            ];
            for (const [p, r] of map) t = t.replace(p, r);
            return fixCapitalization(t);
        }

        function toFriendly(text) {
            let t = text;
            const map = [
                [/\bokay\b/gi, "Sure"],
                [/\bhello\b/gi, "Hey"],
                [/\bthanks\b/gi, "Thanks!"],
            ];
            for (const [p, r] of map) t = t.replace(p, r);
            return fixCapitalization(t);
        }

        function toChat(text) {
            let t = text;
            const map = [
                [/\bthank you\b/gi, "Thanks"],
                [/\bplease\b/gi, "pls"],
            ];
            for (const [p, r] of map) t = t.replace(p, r);
            return fixCapitalization(t);
        }

        // ===============================
        // REPEAT DETECTOR (ORIGINAL TEXT)
        // ===============================
        function getRepeatedWordSuggestions(originalText) {
            if (!originalText) return "No repeated words found.";

            const words = originalText.toLowerCase().split(/\s+/);
            let list = [];

            for (let i = 0; i < words.length - 1; i++) {
                if (words[i] === words[i + 1]) list.push(words[i]);
            }

            if (list.length === 0) return "No repeated words found.";

            return list
                .map((w) => `‚Ä¢ Repeated: "${w}" ‚Üí Suggestion: remove one`)
                .join("\n");
        }

        function highlightRepeats(text) {
            return text.replace(/\b(\w+)\s+\1\b/gi, `<mark class="repeat">$1 $1</mark>`);
        }

        function detectRepetitionsSimple(text) {
            const regex = /\b(\w+)\s+\1\b/gi;
            let m,
                found = new Set();
            while ((m = regex.exec(text)) !== null) found.add(m[1].toLowerCase());
            return Array.from(found);
        }

        // ===============================
        // SPEECH RECOGNITION
        // ===============================
        const SpeechRecognition =
            window.SpeechRecognition || window.webkitSpeechRecognition;

        if (!SpeechRecognition) {
            statusEl.textContent = "Speech Recognition not supported.";
            speakBtn.disabled = true;
        } else {
            const recog = new SpeechRecognition();
            recog.lang = "en-US";
            recog.interimResults = true;
            recog.continuous = true;

            let finalTranscript = "";
            let originalFinal = "";
            let listening = false;
            let lastStart = 0;

            function updateButtons() {
                const has = cleanedTranscriptEl.textContent.trim().length > 0;
                copyBtn.style.display = has ? "inline-block" : "none";
                downloadBtn.style.display = has ? "inline-block" : "none";
                if (saveBtn) saveBtn.style.display = has ? "inline-block" : "none";
            }

            const dictationMap = [
                ["\\bcomma\\b", ","],
                ["\\bperiod\\b", "."],
                ["\\bquestion mark\\b", "?"],
                ["\\bexclamation mark\\b", "!"],
                ["\\bnew line\\b", "\n"],
                ["\\bnew paragraph\\b", "\n\n"],
            ];

            function applyDictation(t) {
                if (!dictationToggle.checked) return t;
                let out = t;
                for (const [p, r] of dictationMap)
                    out = out.replace(new RegExp(p, "ig"), r);
                return out;
            }

            function finalizeSegment(t) {
                t = t.trim();
                if (!t) return "";
                t = t.charAt(0).toUpperCase() + t.slice(1);
                if (!/[.!?]$/.test(t)) t += ".";
                return t + " ";
            }

            recog.onresult = (ev) => {
                const latency = Date.now() - lastStart;
                latencyEl.textContent = `Latency: ${latency} ms`;

                let interim = "",
                    origInterim = "";

                for (let i = ev.resultIndex; i < ev.results.length; i++) {
                    const t = ev.results[i][0].transcript;
                    if (ev.results[i].isFinal) {
                        originalFinal += t + " ";
                        finalTranscript += finalizeSegment(applyDictation(t));
                    } else {
                        interim += applyDictation(t);
                        origInterim += t;
                    }
                }

                const originalText = (originalFinal + origInterim).trim();
                originalTranscriptEl.textContent = originalText || "(listening...)";

                let processed = (finalTranscript + interim).trim();
                transcriptEl.innerHTML = highlightRepeats(processed);

                const cleaned = cleanText(processed);
                const toned = applyTone(cleaned, toneSelect.value);
                cleanedTranscriptEl.textContent = toned;

                suggestionsEl.textContent = getRepeatedWordSuggestions(originalText);

                const r = detectRepetitionsSimple(processed);
                repeatsEl.textContent = r.length
                    ? "Repeated detected: " + r.join(", ")
                    : "";

                updateButtons();
            };

            recog.onend = () => {
                if (listening) {
                    try {
                        recog.start();
                    } catch (e) { }
                    statusEl.textContent = "Listening...";
                    return;
                }
                statusEl.textContent = "Idle";
                speakBtn.textContent = "üéôÔ∏è Speak";
                speakBtn.classList.remove("listening"); // STOP GLOW
            };

            // ===============================
            // MIC BUTTON CLICK (UI ONLY) ‚≠ê
            // ===============================
            speakBtn.onclick = () => {
                if (!listening) {
                    speakBtn.classList.add("listening"); // START GLOW
                    speakBtn.textContent = "üõë Stop";

                    finalTranscript = "";
                    originalFinal = "";
                    originalTranscriptEl.textContent = "";
                    transcriptEl.textContent = "";
                    cleanedTranscriptEl.textContent = "";
                    suggestionsEl.textContent = "";
                    repeatsEl.textContent = "";

                    lastStart = Date.now();
                    recog.start();
                    statusEl.textContent = "Listening...";
                    listening = true;
                } else {
                    speakBtn.classList.remove("listening"); // STOP GLOW
                    recog.stop();
                    statusEl.textContent = "Stopping...";
                    speakBtn.textContent = "üéôÔ∏è Speak";
                    listening = false;
                }
            };

            copyBtn.onclick = async () => {
                const toned = cleanedTranscriptEl.textContent.trim();
                await navigator.clipboard.writeText(toned);
                statusEl.textContent = "Copied!";
                setTimeout(() => (statusEl.textContent = "Idle"), 1000);
            };

            if (saveBtn) {
                saveBtn.onclick = async () => {
                    const original = originalTranscriptEl.textContent.trim();
                    const cleaned = cleanedTranscriptEl.textContent.trim();
                    try {
                        const res = await fetch("/save-transcript", {
                            method: "POST",
                            headers: { "Content-Type": "application/json" },
                            body: JSON.stringify({
                                original_transcript: original,
                                cleaned_transcript: cleaned,
                            }),
                        });
                        if (res.ok) {
                            const j = await res.json();
                            statusEl.textContent = "Saved";
                            if (window.__loadHistory) window.__loadHistory();
                            setTimeout(() => (statusEl.textContent = "Idle"), 1200);
                        } else {
                            const j = await res.json();
                            statusEl.textContent = j.error || "Save failed";
                        }
                    } catch (e) {
                        statusEl.textContent = "Save error";
                    }
                };
            }

            downloadBtn.onclick = () => {
                const original = originalTranscriptEl.textContent.trim();
                const processed = transcriptEl.textContent.replace(/<[^>]+>/g, "").trim();
                const cleanedRaw = cleanText(processed);
                const tone = toneSelect.value || "neutral";
                const cleanedToned = applyTone(cleanedRaw, tone);
                const suggestions = suggestionsEl.textContent.trim();

                const text =
                    "=== ORIGINAL TRANSCRIPT ===\n" +
                    original +
                    "\n\n=== PROCESSED TRANSCRIPT ===\n" +
                    processed +
                    "\n\n=== CLEANED TRANSCRIPT (" +
                    tone +
                    ") ===\n" +
                    cleanedToned +
                    "\n\n=== SUGGESTIONS ===\n" +
                    suggestions;

                const blob = new Blob([text], { type: "text/plain" });
                const url = URL.createObjectURL(blob);
                const a = document.createElement("a");
                a.href = url;
                a.download = "transcript.txt";
                a.click();
                URL.revokeObjectURL(url);
            };

            toneSelect.addEventListener("change", () => {
                const processed = transcriptEl.textContent.trim();
                const cleanedRaw = cleanText(processed);
                cleanedTranscriptEl.textContent = applyTone(
                    cleanedRaw,
                    toneSelect.value || "neutral"
                );
            });

            setInterval(updateButtons, 600);
        }

        async function loadHistory() {
            const el = document.getElementById('historyList');
            try {
                const res = await fetch('/history');
                if (!res.ok) throw new Error('Not authenticated');
                const j = await res.json();
                if (!j.ok) throw new Error('No history');
                if (!j.rows.length) {
                    el.textContent = 'No transcripts yet.';
                    return;
                }
                el.innerHTML = j.rows.map(r => `
                    <div class="history-item p-2 rounded hover:bg-gray-50 border" data-id="${r.id}">
                        <div class="text-xs text-gray-400">${new Date(r.created_at).toLocaleString()}</div>
                        <div class="text-sm text-gray-800 mt-1">${(r.cleaned || '').slice(0, 120)}</div>
                    </div>
                `).join('');
            } catch (err) {
                el.textContent = 'Please login to see history.';
            }
        }

        document.getElementById('logoutBtn').addEventListener('click', async () => {
            await fetch('/logout', { method: 'POST' });
            window.location.href = '/login.html';
        });

        window.__loadHistory = loadHistory;
        loadHistory();
    </script>
</body>

</html>